package projecteuler;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/*
 * The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:
 * 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
 * We can see that 28 is the first triangle number to have over five divisors.
 * What is the value of the first triangle number to have over five hundred divisors?
 */

public class Problem12{
	public static void main(String [] args){
		//System.out.println(new Problem12().sieveOfEratosthenesModified(75000));
		//System.out.println(new Problem12().primeFactorisation(76576500,new Problem12().sieveOfEratosthenesModified(75000)));
		//new Problem12().generateTriangleNumbers(20);
		
		double startTime = System.nanoTime();
		
		new Problem12().numberPrime(500);
		//new Problem12().numberTrial(500);
		
		double endTime = System.nanoTime();
		double difference = (endTime - startTime) / 1000000;
		System.out.println(difference);
	}
	
	void numberTrial(int numOfDivisors){
		int count = 1, n = 1;
		
		while (trialDivision(n) <= numOfDivisors){
			n = count;
			n = n*(n + 1) / 2;
			count++;
		}
		System.out.println(n);
	}
	
	void numberPrime(int numOfDivisors){
		int count = 2, n = 1;
		List<Integer> primesList = sieveOfEratosthenesModified(75000);
		
		while (primeFactorisation(n, primesList) <= numOfDivisors){
			n += count;
			count++;
		}
		System.out.println(n);
	}
	
	//trial division algorithm for integer factorisation
	int trialDivision(int n){
		int numOfDivisors = 0;
		
		for(int i = 1;i <= Math.sqrt(n);i++){
			if(n % i == 0){
				numOfDivisors += 2;//add 2 to number of divisors because we are only checking divisors upto the sqrt of the number, and so we would we be ignoring the divisors greater than the sqrt and we want to know the total number of divisors. every factor comes in a pair. It can be proven that in any factor pair, the smallest factor is <= the square root of the number.
			}
		}
		return numOfDivisors;
	}
	
	//determines the total number of factors of a number by first determining the prime factors of a number and using the exponents of the prime factors to compute the total number of factors.
	//http://mathforum.org/library/drmath/view/57151.html <--- explains in more detail the process.
	int primeFactorisation(int number, List<Integer> listOfPrimes){
		int numOfFactors = 1;
		int numberToFactor = number;
		
		for(int i = 0;i < listOfPrimes.size();i++){
			
			//only need to check prime numbers upto the sqrt(number)
			if(listOfPrimes.get(i) > Math.sqrt(number)){
				return numOfFactors * 2;
			}
			
			int exponent = 1;
			while(numberToFactor % listOfPrimes.get(i) == 0){
				exponent++;
				numberToFactor /= listOfPrimes.get(i);
			}
			numOfFactors *= exponent;
			
			//once numberToFactor == 1, we can break out the loop (by returning) and stop as we have found the solution
			if(numberToFactor == 1){
				return numOfFactors;
			}
		}
		return numOfFactors;
	}
	
	//triangle numbers algorithm
	long [] generateTriangleNumbers(int numOfTerms){
		int count = 1, n = 0;
		long [] triangleNumSeq = new long [numOfTerms];
		
		for(int i = 0;count <= numOfTerms;i++){
			n = count;
			n = n*(n + 1) / 2;
			triangleNumSeq[i] = n;
			count++;
		}
		System.out.println(numOfTerms+" triangle numbers: " + Arrays.toString(triangleNumSeq));
		
		return triangleNumSeq;
	}
	
	List<Integer> sieveOfEratosthenesModified(int n){
		if(n <= 1){
			System.out.println("input should be greater than 1.");
		}
		
		//create boolean array. initially assume all integers are prime therefore mark indexes from 2-10 as true. boolean defaults to false therefore indexes 0 and 1 will be false.
		boolean [] isPrime = new boolean[n+1];
		
		for(int i = 2;i <= n;i++){
			isPrime[i] = true;
		}
		
		//mark all multiples of 2 false. 2 is separate because it is the only even prime number, and therefore it is more efficient to cross out all even numbers separately so then you can focus only on odd numbers as below.
		for(int i = 2;i <= 2;i++){
			if(isPrime[i]){
				for(int j = i;	i*j <= n;	j++){
					isPrime[i*j] = false;
				}
			}
		}
		
		/*
		 * mark non-primes <= n using Sieve of Eratosthenes.
		 * when marking multiples of prime numbers as false, start at (primeNumber squared) because multiples smaller than (primeNumber squared) will have already been marked as false. If (primeNumber squared) is greater than n, you can stop.
		 * i <= sqrt(n) because you do not need to go through every index. e.g. if n = 64 then you only need to go up to i = 8.
		 * only checks the odd numbers
		 */
		for(int i = 3;i <= Math.sqrt(n);i += 2){
			if(isPrime[i]){
				for(int j = i;	i*j <= n;	j+=2){
					isPrime[i*j] = false;
				}
			}
		}
		
		List<Integer> listOfPrimes = new ArrayList<Integer>();
		for(int i = 0;i < isPrime.length;i++){
			if(isPrime[i]){
				listOfPrimes.add(i);
			}
		}
		return listOfPrimes;
	}
}
